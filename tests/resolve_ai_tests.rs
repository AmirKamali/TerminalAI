use std::fs;
use tempfile::TempDir;

#[test]
fn test_detect_package_manager_from_file_npm() {
    let temp_dir = TempDir::new().unwrap();
    let package_json_path = temp_dir.path().join("package.json");

    // Create a test package.json file
    let package_json_content = r#"{
        "name": "test-project",
        "version": "1.0.0",
        "dependencies": {
            "react": "^18.2.0",
            "express": "^4.18.2"
        }
    }"#;

    fs::write(&package_json_path, package_json_content).unwrap();

    // Test that the function correctly detects npm from package.json
    let result = resolve_ai::detect_package_manager_from_file(package_json_path.to_str().unwrap());
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), "npm");
}

#[test]
fn test_detect_package_manager_from_file_python() {
    let temp_dir = TempDir::new().unwrap();
    let requirements_path = temp_dir.path().join("requirements.txt");

    // Create a test requirements.txt file
    let requirements_content = r#"requests==2.31.0
django==4.2.0
numpy>=1.24.0"#;

    fs::write(&requirements_path, requirements_content).unwrap();

    // Test that the function correctly detects python from requirements.txt
    let result = resolve_ai::detect_package_manager_from_file(requirements_path.to_str().unwrap());
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), "python");
}

#[test]
fn test_detect_package_manager_from_file_yarn_lock() {
    let temp_dir = TempDir::new().unwrap();
    let yarn_lock_path = temp_dir.path().join("yarn.lock");

    // Create a test yarn.lock file
    let yarn_lock_content = r#"# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

react@^18.2.0:
  version "18.2.0"
  resolved "https://registry.yarnpkg.com/react/-/react-18.2.0.tgz""#;

    fs::write(&yarn_lock_path, yarn_lock_content).unwrap();

    // Test that the function correctly detects npm from yarn.lock
    let result = resolve_ai::detect_package_manager_from_file(yarn_lock_path.to_str().unwrap());
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), "npm");
}

#[test]
fn test_detect_package_manager_from_file_poetry_lock() {
    let temp_dir = TempDir::new().unwrap();
    let poetry_lock_path = temp_dir.path().join("poetry.lock");

    // Create a test poetry.lock file
    let poetry_lock_content = r#"# This file is automatically @generated by Poetry.
# It is not intended for manual editing.

[[package]]
name = "requests"
version = "2.31.0""#;

    fs::write(&poetry_lock_path, poetry_lock_content).unwrap();

    // Test that the function correctly detects python from poetry.lock
    let result = resolve_ai::detect_package_manager_from_file(poetry_lock_path.to_str().unwrap());
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), "python");
}

#[test]
fn test_detect_package_manager_from_file_content_analysis() {
    let temp_dir = TempDir::new().unwrap();
    let custom_file_path = temp_dir.path().join("custom-deps.json");

    // Create a file with npm-like content
    let npm_content = r#"{
        "dependencies": {
            "react": "18.2.0"
        },
        "devDependencies": {
            "typescript": "5.0.0"
        }
    }"#;

    fs::write(&custom_file_path, npm_content).unwrap();

    // Test that the function correctly detects npm from content analysis
    let result = resolve_ai::detect_package_manager_from_file(custom_file_path.to_str().unwrap());
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), "npm");

    // Create a file with python-like content
    let python_file_path = temp_dir.path().join("custom-deps.txt");
    let python_content = r#"requests==2.31.0
django>=4.2.0
numpy<=1.25.0"#;

    fs::write(&python_file_path, python_content).unwrap();

    // Test that the function correctly detects python from content analysis
    let result = resolve_ai::detect_package_manager_from_file(python_file_path.to_str().unwrap());
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), "python");
}

#[test]
fn test_detect_package_manager_from_file_nonexistent() {
    // Test that the function returns an error for nonexistent files
    let result = resolve_ai::detect_package_manager_from_file("nonexistent-file.json");
    assert!(result.is_err());
    let error_msg = result.unwrap_err().to_string();
    assert!(error_msg.contains("does not exist"));
}

#[test]
fn test_detect_package_manager_from_file_unknown_format() {
    let temp_dir = TempDir::new().unwrap();
    let unknown_file_path = temp_dir.path().join("unknown.txt");

    // Create a file with unknown format
    let unknown_content = "This is just some random text without any package manager indicators.";

    fs::write(&unknown_file_path, unknown_content).unwrap();

    // Test that the function returns an error for unknown formats
    let result = resolve_ai::detect_package_manager_from_file(unknown_file_path.to_str().unwrap());
    assert!(result.is_err());
    let error_msg = result.unwrap_err().to_string();
    assert!(error_msg.contains("Could not detect package manager type"));
}

// Mock module for testing - this would need to be properly integrated with the actual resolve_ai module
mod resolve_ai {
    use anyhow::Result;
    use std::path::Path;

    pub fn detect_package_manager_from_file(file_path: &str) -> Result<String> {
        let path = Path::new(file_path);

        // Check if file exists
        if !path.exists() {
            return Err(anyhow::anyhow!(
                "Dependency file '{}' does not exist",
                file_path
            ));
        }

        // Get file name and extension
        let file_name = path
            .file_name()
            .and_then(|name| name.to_str())
            .ok_or_else(|| anyhow::anyhow!("Invalid file path"))?;

        let file_name_lower = file_name.to_lowercase();

        // Detect package manager based on file name
        match file_name_lower.as_str() {
            "package.json" | "package-lock.json" | "yarn.lock" => Ok("npm".to_string()),
            "requirements.txt" | "poetry.lock" | "pipfile" | "pipfile.lock" => {
                Ok("python".to_string())
            }
            _ => {
                // Try to read file content for better detection
                let content = std::fs::read_to_string(path)
                    .map_err(|_| anyhow::anyhow!("Could not read file '{}'", file_path))?;

                if content.contains("\"dependencies\"") || content.contains("\"devDependencies\"") {
                    Ok("npm".to_string())
                } else if content.contains("==") || content.contains(">=") || content.contains("<=")
                {
                    Ok("python".to_string())
                } else {
                    Err(anyhow::anyhow!(
                        "Could not detect package manager type from file '{}'. Supported files: package.json, requirements.txt, yarn.lock, poetry.lock, Pipfile",
                        file_path
                    ))
                }
            }
        }
    }
}
